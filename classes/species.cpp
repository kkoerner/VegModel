//---------------------------------------------------------------------------

//#include <vcl.h>
//#include <stdlib.h>
#pragma hdrstop

//#include "mclasses.h"// needs class Random
#include "prefs.h"
#include "species.h"
#include "random.h"
//#include <iostream> //for using cout in develloping time

//---------------------------------------------------------------------------

/** \file
  \brief Implementation of class Population
*/

//--class Population{}---------------------------------------------------
Population::Population(){
  adults=0;
  seedProd=0;
  stadium[0]=0; stadium[1]=0;stadium[2]=0;stadium[3]=0;stadium[4]=0;
  managed=false;
}
void Population::init(void){
  Population();
  maxCapacity=0;
  actCapacity=maxCapacity;
}

///zählt alle Individuen der grünen Stadien
long Population::getInds(void) const {
  long inds=0;
  for (int i=SEEDL; i<=GEN; i++) //i=seedlings
    inds+=stadium[i];
  return inds;
}

///setzt generative auf inds, alle anderen gleich 0; Samenbank bleibt
void Population::resetInds(int inds=0){
  stadium[GEN]=inds; //Samenbank unberührt: stadium[seeds]=0;
  stadium[SEEDL]=0;stadium[JUV]=0;stadium[VEG]=0;
}

///\name  communicate with private variables
//@{
long Population::getSeeds() const {
  return stadium[SEED];
}
void Population::addSeeds(long lseeds, int lstr){
  stadium[SEED]+=lseeds;
  if(stadium[SEED]<0) stadium[SEED]=0;
}

long Population::getStadium(state stad) const {
  return stadium[stad];
}

long Population::getSummerPop(int stad) const {
  return summerpop[(state)stad];
}
//@}

/// returns the stochastic portion 'p' of  number 'number'
/**
  Function returning the stochastic result of probability with number trials.
  The result is deterministic if number * p exceeds a threshold (level).
  \param number number of trials
  \param p probability
  \param level level of stochasticity (default is 100)
  \return integer number
*/
inline int stoch(const int number, const double p,const int level=100){
 //int count=0;
 if (p==0) return 0;
 if (number*p>level)return (int)(number*p);//to reduce calc-time
 //for (int i=0; i<number; i++) if (p>rand()/(double)RAND_MAX) count++;
 //return count;
 //return not more individuals than initially evident
 return min(number,MRandom::randomNb->poisson(number*p));
}
//---Demographie-------------------------------------------------------

///bestimme 'adults'(genAd) und berechne die Samenproduktion abhängig vom Wetter
/**
    Calculates the number of produced seeds of a certain population depending
    on the current weather quality

    The number of seeds is stored in a local variable. Seeds are dispersed
    'at the end of the year' with the function Landscape::seedDispersal(...).

   \param quality years' weather quality for seed production;
          generated by function Climate::calcWeather() \n
          possible values: 0.5 / 1.0 / 1.5

   \sa  Landscape::oneYear()
*/
void Population::seedProduction(float quality){
  seedProd=0;
  long genInds= stadium[GEN];
  seedProd=long (quality*Preferences::getMan((process)2)*
           Preferences::getTransition(GEN,SEED)*(float)genInds);
}

/// klonales Wachstum der Population - Wetter-

/**
  Clones of vegetative and generative stage are added to the juvenile stage.
  If the sum of adults and clones exceeds actual capacity,  the number of
  clones is cutted to hold that level.

  \param quality years' weather quality for clonal Growth (same as for seedProd.);
          generated by function Climate::calcWeather()  \n
          possible values: 0.5 / 1.0 / 1.5

   \sa  Landscape::oneYear()
  */
void Population::clonalGrowth(float quality){
//  using Preferences::getTransition;
  int clones=int(quality // *Preferences::getMan(3)
                    *(Preferences::getTransition(VEG,JUV)*stadium[VEG]
                    + Preferences::getTransition(GEN,JUV)*stadium[GEN]));

  if (clones+adults > actCapacity)  clones = (long)actCapacity-adults;
  stadium[JUV]+=clones;
}

/// SeedMortality
/**
  Seed survival is calculated as given in the transition matrix.
  If the number of seeds is low (\f$<10\f$), seed mortality is stochastic.

   \sa  Landscape::oneYear()
  */
void Population::seedMort(){
  if (stadium[SEED]<0)  { //|| stadium[seeds]>LONG_MAX)
    stadium[SEED]=LONG_MAX;  }
  //berechne Samenmortalität
  stadium[SEED]=stoch(stadium[SEED],Preferences::getTransition(SEED,SEED));
}

/// Alterung der Individuen

/**
   Annual ageing of Individuals is calculated. This is the growth function and
   has the transition matrix as input parameters. Ageing is not weather dependent.

   \param quality years' weather quality for Growth -not used at
          the current version of the model-;
          generated by function Climate::calcWeather()  \n
          possible values: 0.5 / 1.0 / 1.5

   \sa  Landscape::oneYear()
*/
void Population::aging(float quality){
  //std::cout<<"ageing...";
  // Alterung..
  long int add[5]={0,0,0,0,0}; long int sub[5]={0,0,0,0,0};  //Zwischenspeicher
  for (int from=JUV; from<=VEG; from++)
    for (int to=from+1; to<=GEN; to++){
      //Übergänge anhand der Raten berechnen -
      // seit 080527 mit stochastik
      int change=stoch(stadium[(state)from],Preferences::getTransition((state)from,(state)to));
      add[(state)to]   += change;
      sub[(state)from] += change;
    }
  // Addiere die Veränderungen
  for (int n=SEEDL; n<=GEN; n++) {
    stadium[n]+=add[n]-sub[n];
    if (stadium[n]<0) stadium[n]=0;
  }
}

///Retrogression  - auch Simulation von Pflanzendormanz
/**
  Calculates the transition of generative individuals to vegetative ones.
  The Parameter is given in the transition matrix. Influence of weather

   \param quality combined weather quality for Survival and fecundity processes
          generated by function Climate::calcWeather()  \n
          possible values: 0.25 / 0.5 / 0.75 / 1.0 / 1.5 / 2.25

   \sa  Landscape::oneYear()
*/
void Population::retrogression(float quality){
  int number=0;  //Zwischenspeicher
  state from=GEN; state to=VEG;
  if (quality<0.5){
    //wenn Wetter schlecht, dann Ü ins vegetative bzw dormante Stadium
    //Übergänge anhand der Raten berechnen //mit stoch ab V080508
    number   = stoch(stadium[from],Preferences::getTransition(from,to));
    // Addiere die Veränderungen
    stadium[to]+=number;stadium[from]-=number;
  }
}

///berechne Keimung und Etablierung (danach vollst. adult)
/**
  Calculation of germination and establishment. Uses parameters in
  transition matrix.

  Germination is weather dependent and can be modified by management settings:
  \f$ germRate = quality*management*transition[seeds,SEEDL]\f$
  For low seed bank (\f$<10\f$) germination is stochastic.

  Establishment to one of the older stages is calculated subsequently.
  It is density dependent after the following equeation:
   \f{equnarray*}
      estabRate=seedlings*transition\[ seedl,stage \]
      \left\( 1-a \frac{\sum Individuals}{Capacity} \right\)
   \f}

   \param quality years' weather quality for Establishment phase
          generated by function Climate::calcWeather()  \n
          possible values: 0.5 / 1.0 / 1.5

   \sa  Landscape::oneYear()
*/
void Population::germEstab(float quality){
  float capacity = actCapacity;
  if(capacity>0 && (stadium[SEED]>0||stadium[SEEDL]>0)){
    double de=1.0;   //Korrekturfaktor für Dichteregulierung zZ ungenutzt
    long seedl=0;
    //Keimung.. hier ggf demograph. Rauschen einfügen //done V080527
    seedl=stoch(stadium[SEED],quality*Preferences::getMan((process)0)*
                          Preferences::getTransition(SEED,SEEDL));
    stadium[SEED]-=seedl;
    seedl+=stadium[SEEDL]; //dies- plus vorjährige Keimlinge
    stadium[SEEDL]=seedl; //Stadium der Keimlinge setzen
    //Dichteabhängige Keimlingsmortalität (!?Formel)
    float RateEstabed=0;
    for (int i=JUV;i<=GEN;i+=1) {
      //stochast ab V080508
      long estab =stoch(seedl,Preferences::getTransition(SEEDL,(state)i)*
        (1-(de*getInds())/capacity)); // a*seedl
      if (estab>0) {
        stadium[(state)i]+=estab;        //Keinlinge etablieren sich
        stadium[SEEDL]-=estab;
      }
      RateEstabed+=Preferences::getTransition(SEEDL,(state)i);//berechne Gesamtetablierungsrate
    }
    long staying= stoch( seedl,(1-RateEstabed));
    if (staying<0) staying=0;
    stadium[SEEDL]=staying; //setze nicht etablierte Keimlinge
  }
  // adults--> Zahl der adulten Individuen zur Vegetationszeit
  adults = stadium[GEN]+stadium[VEG];
  indsReg= getInds();    //#Individuen nach Etablierung
  for (int i=0; i<5; i+=1) summerpop[(state)i]=stadium[(state)i];
}

///berechne Mortalität

/**natürliche und sukzessions-mortalität \n
  alle Stadien - Diagonale entspr. SurvivalRate      \n
  concurrenzIntensity zZ ohne Bedeutung
*/
void Population::mortality(float concurrenzIntensity,float quality){
//  using Preferences::getMan;
  double gamma=2;
  float capacity = actCapacity; long inds=getInds();
  //Konkurrenz der Subadulten mit allen Individuen
  float compSubad= gamma-(inds/(capacity+0.001));
  if (compSubad>1) compSubad=1; else if (compSubad<0) compSubad=0;
  //Konkurrenz der Adulten nur mit den adulten Stadien
  float compAd= gamma-(adults/(capacity+0.001));
  if (compAd>1) compAd=1; else if (compAd<0) compAd=0;
  for (int stad=SEEDL; stad<=GEN; stad+=1){
    float surv=(Preferences::getTransition((state)stad,(state)stad));
    if (stad>JUV) surv*=compAd*quality*Preferences::getMan(SURV);
     else              surv*=compSubad*quality*Preferences::getMan(SURV);
    if (surv>1) surv=1.0;    //surv max. 1
    stadium[stad]=stoch(stadium[stad],surv);
  }//for stad
}
//-------------------------------------------------------------------
#pragma package(smart_init)
